// typescript polyfill
declare global {
    interface SymbolConstructor {
        readonly metadata: unique symbol
    }
}
// runtime polyfill
if (typeof Symbol.metadata === 'undefined') {
    // @ts-expect-error
    Symbol.metadata = Symbol('Symbol.metadata')
}

console.info(`Generated by Hello World`);


// InjectionKey 用于定义依赖注入的标识符, 可是实现标志服和协议的绑定
export interface InjectionKey<T> extends Symbol { }

const METADATA_KEY: unique symbol = Symbol('METADATA_KEY')

// 作用域类型, 作为简单示例，我们就支持两种作用域类型
export enum Scope {
    Singleton,
    Transient
}

interface Injection {
    key: InjectionKey<unknown>;
    multiple?: boolean;
    context: ClassFieldDecoratorContext;
}


interface InjectionMetadata {
    injectable?: InjectionKey<unknown>;
    scope?: Scope;
    injections?: Map<PropertyKey, Injection>;

}

// 获取或创建元数据
function getOrCreateMetadata<T>(metadata: DecoratorMetadata): InjectionMetadata {
    if (metadata == null) {
        throw new Error('Decorator metadata is not defined')
    }

    return metadata[METADATA_KEY] ?? (metadata[METADATA_KEY] = {})
}


// 通过 key 和 context 将类注入到属性中
function injectToField(injection: Injection) {
    const { context } = injection

    if (context.static === true) {
        throw new Error('inject cannot be used on static fields')
    }

    const metadata = getOrCreateMetadata(context.metadata)

    // 保存当前类上的注入信息
    if (metadata.injections == null) {
        metadata.injections = new Map()
    }

    if (metadata.injections.has(context.name)) {
        throw new Error(`inject is already defined for ${context.name.toString()}`)
    }

    // 关联当前属性名 --> 注入信息
    metadata.injections.set(context.name, injection)
}

// 类装饰器，支持被注入的类都需要使用它来装饰
// 可以接受一个 scope，默认为 单例
export function injectable<T, Class extends abstract new (...args: any) => T>(
    key: InjectionKey<T>,
    scope = Scope.Singleton
) {
    return (_: Class, context: ClassDecoratorContext<Class>) => {
        const metadata = getOrCreateMetadata(context.metadata);

        if(metadata.injectable) {
            throw new Error(`@injectable can only be used once per class`);
        }

        // 保存注入的类的标示信息
        metadata.injectable = key;

        // 保存注入的类作用域
        metadata.scope = scope;
    }
}

// 属性装饰器, 声明注入
export function inject<T>(key: InjectionKey<T>) {
    return (_: undefined, context: ClassFieldDecoratorContext<unknown, T | undefined>) => {
        injectToField({ key, context })
    }
}

export function injectAll<T>(key: InjectionKey<T>) {
    return (value: undefined, context: ClassFieldDecoratorContext<unknown, T[] | undefined>) => {
        injectToField({ key, multiple: true, context })
    }
}


type Ctor<T = unknown> = new (...args: any) => T
export class Container {
    // 绑定关系
    private bindings: Map<InjectionKey<unknown>, Ctor[]> = new Map()

    // 单例对象池
    private pools: Map<Ctor, unknown> = new Map()

    // 正在创建的对象
    private creating: Map<Ctor, unknown> = new Map()

    // 创建绑定关系，将 key 跟具体的构造函数关联上
    bind<T>(key: InjectionKey<T>, impl: new (...args: any) => T) {
        if (impl[Symbol.metadata] == null) {
            throw new Error(`No metadata found for ${impl.name}`)
        }

        if (this.bindings.has(key)) {
            this.bindings.get(key)!.push(impl)
        } else {
            this.bindings.set(key, [impl])
        }
    }

    // 根据 key 获取对应的实例
    get<T>(key: InjectionKey<T>): T {
        return this.resolve(key, false) as T
    }

    // 根据 key 获取对应的实例数组
    getAll<T>(key: InjectionKey<T>): T[] {
        return this.resolve(key, true) as T[]
    }

    // 根据 key 解析实例
    // multiple: 是否允许多实例
    private resolve(key: InjectionKey<unknown>, multiple: boolean): unknown {
        // 根据 key 获取对应的构造函数
        const binding = this.bindings.get(key)


        if (binding == null) {
            throw new Error(`No binding found for ${key.toString()}`)
        }

        if (!multiple && binding.length > 1) {
            throw new Error(`Multiple bindings found for ${key.toString()}`)
        }

        // 创建出实例
        return multiple
            ? binding.map((impl) => this.createInstance(impl))
            : this.createInstance(binding[0])
    }


    // 对象实例化
    private createInstance(impl: Ctor): unknown {
        // 正在创建中
        if (this.creating.has(impl)) {
            return this.creating.get(impl)
        }


        if (impl[Symbol.metadata] == null) {
            throw new Error(`No metadata found for ${impl.name}`)
        }

        // 这里是关键：从这里可以获取当前类上的注入信息，这里有两种情况：
        // 如果 metadata.injectable 为空，说明当前类没有被 @injectable 装饰器标记，无法进行依赖注入
        // 如果 metadata.injections 为空，说明当前类的属性没有被 @inject 装饰器标记，不需要进行依赖注入
        const metadata = impl[Symbol.metadata]![METADATA_KEY] as InjectionMetadata | undefined

        if (metadata == null || metadata.injectable == null) {
            throw new Error(`No injectable found for ${impl.name}`)
        }

        // 获取注入信息，包含注入的类型，注入的属性，作用域等
        const { scope = Scope.Singleton, injections } = metadata

        // 单例
        if (scope === Scope.Singleton && this.pools.has(impl)) {
            return this.pools.get(impl)
        }

        // 实例化
        const instance = new impl()

        // 将实例放在创建中集合，防止循环依赖
        this.creating.set(impl, instance)

        try {
            // 依赖注入，如果 metadata.injections 不为空，说明当前类的属性有被 @inject 装饰器标记，需要进行依赖注入
            if (injections != null) {
               
                // injections 是一个 Map，key 是属性名，value 是 Injection 对象
                for (const injection of injections.values()) {
                    const { key, context, multiple } = injection
                    const value = multiple ? this.getAll(key) : this.get(key)

                    // 将属性值改成对应的实例
                    // 用起来非常方便，我们不需要关心属性的存储过程，比如私有属性
                    context.access.set(instance, value)
                }
            }

            if (scope === Scope.Singleton) {
                this.pools.set(impl, instance)
            }
        } finally {
            this.creating.delete(impl)
        }

        return instance
    }
}

